name: Build and Deploy to Azure VM

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  AZURE_VM_NAME: 'servicebustry'
  AZURE_RESOURCE_GROUP: 'tries'
  BACKEND_PATH: 'backend'
  FRONTEND_PATH: 'frontend'
  BACKEND_ARTIFACT_NAME: 'backend-app'
  FRONTEND_ARTIFACT_NAME: 'frontend-app'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '8.0.x'

    - name: Build .NET Backend
      run: dotnet publish ${{ env.BACKEND_PATH }}/servicebusapi2.csproj -c Release --output ${{ env.BACKEND_PATH }}/publish

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'

    - name: Build Frontend
      run: |
        cd ${{ env.FRONTEND_PATH }}
        npm install
        npm run build

    - name: Upload Backend Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.BACKEND_ARTIFACT_NAME }}
        path: ${{ env.BACKEND_PATH }}/publish

    - name: Upload Frontend Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.FRONTEND_ARTIFACT_NAME }}
        path: ${{ env.FRONTEND_PATH }}/dist

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Start VM
      uses: azure/CLI@v1
      with:
        inlineScript: |
          az vm start --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_VM_NAME }}

    - name: Get backend artifact URL
      id: backend_artifact
      uses: actions/github-script@v6
      with:
        script: |
          const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
            owner: context.repo.owner,
            repo: context.repo.repo,
            run_id: context.runId,
          });
          const backendArtifact = artifacts.data.artifacts.find(artifact => artifact.name === '${{ env.BACKEND_ARTIFACT_NAME }}');
          return backendArtifact.archive_download_url;

    - name: Get frontend artifact URL
      id: frontend_artifact
      uses: actions/github-script@v6
      with:
        script: |
          const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
            owner: context.repo.owner,
            repo: context.repo.repo,
            run_id: context.runId,
          });
          const frontendArtifact = artifacts.data.artifacts.find(artifact => artifact.name === '${{ env.FRONTEND_ARTIFACT_NAME }}');
          return frontendArtifact.archive_download_url;

    - name: Run Setup Script on VM
      uses: azure/CLI@v1
      with:
        inlineScript: |
          # Create a temporary script file on the runner
          cat << 'EOF' > deploy_script.sh
          #!/bin/bash
          set -e # Exit immediately if a command exits with a non-zero status.

          # Parameters from workflow:
          BACKEND_URL="$1"
          FRONTEND_URL="$2"
          GITHUB_TOKEN="$3"
          SB_CONN="$4"
          PUB_TOPIC="$5"
          SCHED_TOPIC="$6"

          # Install dependencies
          sudo apt-get update && sudo apt-get install -y dotnet-runtime-8.0 nginx unzip

          # Download artifacts using the token
          sudo wget --header="Authorization: Bearer $GITHUB_TOKEN" -O /tmp/backend.zip "$BACKEND_URL"
          sudo wget --header="Authorization: Bearer $GITHUB_TOKEN" -O /tmp/frontend.zip "$FRONTEND_URL"

          # Prepare directories
          sudo rm -rf /var/www/*
          sudo mkdir -p /var/www/backend /var/www/frontend

          # Unzip artifacts
          sudo unzip -o /tmp/backend.zip -d /var/www/backend
          sudo unzip -o /tmp/frontend.zip -d /var/www/frontend

          # Find the main application DLL dynamically
          DLL_NAME=$(sudo find /var/www/backend -type f -name '*.dll' ! -name 'Azure.*.dll' ! -name 'Microsoft.*.dll' -printf '%f\n' | head -n 1)
          if [ -z "$DLL_NAME" ]; then
            echo "Error: Could not find the main application DLL"
            exit 1
          fi

          # Create backend service file
          echo "[Unit]
Description=Service Bus API Backend
[Service]
WorkingDirectory=/var/www/backend
ExecStart=/usr/bin/dotnet /var/www/backend/$DLL_NAME
Restart=always
User=www-data
Environment=ASPNETCORE_ENVIRONMENT=Production
Environment="SERVICEBUS_CONNECTION=$SB_CONN"
Environment="PUBLISH_TOPIC=$PUB_TOPIC"
Environment="SCHEDULE_TOPIC=$SCHED_TOPIC"
Environment="AngularAppUrl=http://$(curl -s ifconfig.me)"
[Install]
WantedBy=multi-user.target" | sudo tee /etc/systemd/system/servicebusapi.service

          # Create nginx config file
          echo 'server {
              listen 80;
              server_name _;
              root /var/www/frontend;
              index index.html;
              location / {
                  try_files \$uri \$uri/ /index.html;
              }
              location /api {
                  proxy_pass http://localhost:5000;
              }
          }' | sudo tee /etc/nginx/sites-available/default

          # Set permissions and restart services
          sudo chown -R www-data:www-data /var/www
          sudo systemctl daemon-reload
          sudo systemctl enable servicebusapi.service
          sudo systemctl restart servicebusapi.service
          sudo systemctl restart nginx
          EOF

          # Execute the script on the VM, passing the file path
          az vm run-command invoke \
            -g ${{ env.AZURE_RESOURCE_GROUP }} \
            -n ${{ env.AZURE_VM_NAME }} \
            --command-id RunShellScript \
            --parameters \
              "BackendUrl=${{ steps.backend_artifact.outputs.result }}" \
              "FrontendUrl=${{ steps.frontend_artifact.outputs.result }}" \
              "GitHubToken=${{ secrets.GITHUB_TOKEN }}" \
              "ServiceBusConnection=${{ secrets.SERVICEBUS_CONNECTION }}" \
              "PublishTopic=${{ secrets.PUBLISH_TOPIC }}" \
              "ScheduleTopic=${{ secrets.SCHEDULE_TOPIC }}" \
            --scripts @deploy_script.sh
